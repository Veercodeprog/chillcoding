//INSTEAD of creating our own signaling server and use websockets manually,we are going to use agora
let APP_ID = "e7097e6b6ed14f808bc2afc8bab3fa16";
let token = null;
let uid = String(Math.floor(Math.random() * 10000))
let client;
let channel;
let queryString = window.location.search
let urlParams = new URLSearchParams(queryString)
let roomId = urlParams.get('room')
if (!roomId) {
    window.location = 'lobby.html'
}


let localStream;
let remoteStream;
let peerConnection
const servers = {
    iceServers: [{
        urls: ['stun:stun1.1.google.com:19302', 'stun:stun2.1.google.com:19302']
    }]
}
let constraints = {
    video: {
        width: { min: 640, ideal: 1920, max: 1920 },
        height: { min: 480, ideal: 1080, max: 1080 }

    },
    audio: true
}
let init = async() => {
    client = await AgoraRTM.createInstance(APP_ID);
    await client.login({ uid, token })

    //pass the room id
    channel = client.createChannel(roomId)
    await channel.join()

    channel.on('MemberJoined', handleUserJoined)

    channel.on('MemberLeft', handleUserLeft)
    client.on('MessageFromPeer', handleMessageFromPeer)

    localStream = await navigator.mediaDevices.getUserMedia(constraints);
    document.getElementById("user-1").srcObject = localStream;

}

let handleUserLeft = async(MemeberId) => {
    document.getElementById('user-2 ').style.display = 'none'
    document.getElementById("user-2").classList.remove('smallFrame');

}

let handleMessageFromPeer = async(message, MemeberId) => {
    message = JSON.parse(message.text)

    if (message.type === 'offer') {
        createAnswer(MemeberId, message.offer)
    }

    if (message.type === 'answer') {
        addAnswer(message.answer)
    }

    if (message.type === 'candidate') {
        if (peerConnection) {
            peerConnection.addIceCandidate(message.candidate)
        }
    }
    // console.log('Message: ', message)
}

let handleUserJoined = async(MemeberId) => {
    console.log('A new user  joined : ', MemeberId)
    createOffer(MemeberId);

}

let createPeerConnection = async(MemeberId) => {
    peerConnection = new RTCPeerConnection(servers);

    //In WebRTC, a MediaStream represents a stream of media data, such as audio and video.remoteStream is being initialized as a new MediaStream object. 
    remoteStream = new MediaStream();

    // we are creating a video frame or gettiing it ready for remote user,even if the connection is not there yet
    document.getElementById("user-2").srcObject = remoteStream;

    document.getElementById("user-2").style.display = 'block';

    document.getElementById("user-1").classList.add('smallFrame');





    if (!localStream) {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
        document.getElementById("user-1").srcObject = localStream;

    }


    // This code adds the tracks from the local media stream to the peer connection. The forEach loop iterates over each track in the stream and adds it to the peer connection using the addTrack method.
    localStream.getTracks().forEach((track) => {
        peerConnection.addTrack(track, localStream)
    })


    // This code sets up a listener for the ontrack event, which is triggered when a remote track is added to the peer connection. The forEach loop adds each track from the remote stream to the remoteStream object, which is used to display the remote video feed.
    peerConnection.ontrack = (event) => {
            event.streams[0].getTracks().forEach((track) => {
                remoteStream.addTrack(track);
            })
        }
        // This code sets up a listener for the onicecandidate event, which is triggered when a new ICE candidate is generated by the peer connection. ICE candidates are used to establish a connection between peers across the internet. The if statement checks whether a candidate has been generated, and logs it to the console.
    peerConnection.onicecandidate = async(event) => {
        if (event.candidate) {
            client.sendMessageToPeer({ text: JSON.stringify({ 'type': 'candidate', 'candidate': event.candidate }) }, MemeberId)
        }
    }
}

//RTCPeerConnection:-It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed.
let createOffer = async(MemeberId) => {
    await createPeerConnection(MemeberId);

    // This code generates an SDP offer for the peer connection, which describes the configuration of the media streams and network addresses for the connection. The createOffer method returns a Promise that resolves with the offer, which is then set as the local description of the peer connection using the setLocalDescription method. 
    let offer = await peerConnection.createOffer()
    await peerConnection.setLocalDescription(offer)
    console.log("Offer :", offer);
    client.sendMessageToPeer({ text: JSON.stringify({ 'type': 'offer', 'offer': offer }) }, MemeberId)

}

let createAnswer = async(MemeberId, offer) => {
    await createPeerConnection(MemeberId);
    await peerConnection.setRemoteDescription(offer)
    let answer = await peerConnection.createAnswer()
    await peerConnection.setLocalDescription(answer)
    client.sendMessageToPeer({ text: JSON.stringify({ 'type': 'answer', 'answer': answer }) }, MemeberId)

}

let addAnswer = async(answer) => {
    if (!peerConnection.currentRemoteDescription) {
        peerConnection.setRemoteDescription(answer)
    }

}


let leaveChannel = async() => {
    await channel.leave()
    await client.logout()
}
let toggleCamera = async() => {
    let videoTrack = localStream.getTracks().find(track => track.kind === 'video')

    if (videoTrack.enabled) {
        video.enabled = false;
        document.getElementById('camera-btn').style.backgroundColor = 'rgb(255,80,80)'
    } else {
        videoTrack.enabled = true;
        document.getElementById('camera-btn').style.backgroundColor = 'rgb(179,102,249, .9)'
    }

}

let toggleMic = async() => {
        let audioTrack = localStream.getTracks().find(track => track.kind === 'audio')

        if (audioTrack.enabled) {
            audioTrack.enabled = false;
            document.getElementById('mic-btn').style.backgroundColor = 'rgb(255,80,80)'
        } else {
            audioTrack.enabled = true;
            document.getElementById('mic-btn').style.backgroundColor = 'rgb(179,102,249, .9)'
        }

    }
    // let toggleMic = async() => {
    //     let audioTrack = localStream.getTracks().find(track => track.kind === 'audio')

//     if (audioTrack.enabled) {
//         audioTrack.enabled = false;
//         document.getElementById('mic-btn').style.backgroundColor = 'rgb(255,80,80)'
//     } else {
//         audioTrack.enabled = true;
//         document.getElementById('mic-btn').style.backgroundColor = 'rgb(179,102,249, .9)'
//     }

// }
window.addEventListener('beforeunload', leaveChannel)
document.getElementById('camera-btn').addEventListener('click', toggleCamera)
document.getElementById('mic-btn').addEventListener('click', toggleMic)

init();